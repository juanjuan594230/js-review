{"_id":"note:LRmvYFIUm","title":"vue-router","content":"# router\n\n## SPA & 前端路由\n\n> SPA 通过动态重写当前页面来与用户交互，而非传统的从服务器重新加载整个页面。\n\n### SPA & 浏览器历史记录\n\n整个应用只有一个页面，看起来的多页面是由JS操作来完成的。因此在操纵浏览器的历史记录时（比如回退），可能返回的真正的上一个页面，而不是用户期望的SPA应用中的上个页面。\n\n因此需要用到前端路由。\n\n前端路由：通过JS操纵浏览器的会话历史。\n\n### Frontend Routing\n\n- hash mode\n- history mode\n\n#### hash mode\n\nhash: URL中`#`及之后的内容\n\nhash值的变化，不会重新向服务器发送请求；会触发hashchange事件(浏览器前进/后退，window.location.hash = 'xxx')，可以在事件处理程序中做一些操作。\n\n```javascript\n// url: http://growth-material.corp.kuaishou.com/#/agentManagement\nwindow.location.hash = '#/agentManagement';\n```\n\n一个例子：`window.location.hash`重新赋值会修改浏览器的会话记录。\n\n```javascript\n// https://fanyi.baidu.com/\n// window.location.hash = '#/aaa' 地址栏变成 https://fanyi.baidu.com/#/aaa\n// window.location.hash = '#/bbb' 地址栏变成 https://fanyi.baidu.com/#/bbb\n\n// 操作浏览器的后退按钮，地址栏变成 https://fanyi.baidu.com/#/aaa\n// 操作浏览器的后退按钮 地址栏变成 https://fanyi.baidu.com\n\n// 操作浏览器的前进按钮 地址栏变成 https://fanyi.baidu.com/#/aaa\n```\n\n### history mode\n\nHTML5提供了操纵浏览器会话记录的API `pushState` `replaceState`\n\n`popstate`事件可以监听浏览器的前进、后退操作；以及`history.back()` `history.forward()` `history.go()`\n\n**path的切换会向服务器发起请求，所以history模式下，需要在nginx层（或web服务器层）做配置（统一都返回index.html），否则可能会出现404**\n\n## Vue-Router\n\n### 行为层\n\n#### 用户行为\n\n点击页面中的link标签、点击手动调用push/replace API ，最终都会触发transitionTo，找到匹配的route，执行完所有的导航守卫、完成route的更新之后，会调用**pushHash**或者**pushState**完成会话记录的更新。(pushHash方法中，如果browser支持pushState，则会调用pushState完成会话记录的添加；不支持的话，会直接修改window.location.hash<会话记录会相应改变>).\n\n#### 浏览器行为\n\n点击浏览器的前进后退按钮、或者通过history API（back、forward、go）操作会话历史，则会触发popstate事件或者hashchange事件，通过注册的事件处理函数调用transitionTo()完成路由的匹配及更新。\n\n==push()中通过window.location.hash = XXX的方式更新hash值，会触发hashchange事件。代码中监听的hashchange事件，其处理函数中又会调用transitionTo()做路由切换，不会有问题吗？==\n\ntransitionTo中调用confirmTransition中会对相同路由做判断。\n\n### 响应式\n\n#### 派发更新\n\n==vmRoot._route = route; vmRoot._route setter trigger==\n\ntransitionTo()完成路由的匹配、导航守卫等操作后，会updateRoute\n\t在updateRoute中，首先会修改history.current；其次调用history.cb(route);\n\t\thistory.cb是在router init的时候，调用history.listen(cb)完成赋值的。\n\t\t\tcb = (route) > { 遍历router.apps, 更改app._route = route }\n\tupdateRoute之后，vueRootInstance._route更新；\n\tbeforeCreate()中，对vueRootInstance._route做了响应式处理，setter触发后，对应的依赖watcher会更新（包括router-view组件，重新根据当前的route，匹配需要渲染的组件，完成派发更新）\n\n#### 依赖收集\n\n**summary**\n\nvmRoot._route 响应式\n\nvmInstance.$route -> vmRoot._route\n\nRouter-View Component -> render fn (get vmInstance.$route) -> vmRoot._route(对router-view render watcher add dep)\n\n**detail**\n\ninstall\n\nObject.defineProperty(Vue.prototype, '$route', {\n    get() { return this._routerRoot._route }; // this._routerRoot 根Vue实例\n});\n\nVue.mixin(\n    beforeCreate() {\n        ...\n        Vue.util.defineReactive(this, '_route', this._router.history.current); // 对vmRoot._route做了响应式处理\n    }\n)\n\nRouter-View Component\n\nconst route = parent.$route; // 读取了vmRoot._route，所以对Router-View Component render watcher做了依赖收集。\n\n\n\n```javascript\nhistory.confirmTransition(route, onComplete, onAbort) {\n    ...\n    onComplete();\n}\n\nfunction onComplete() {\n    const prev = this.current\n    this.updateRoute(route)\n    // ...\n}\n\nfunction updateRoute(route) {\n    history.current = route;\n    history.cb && history.cb(route); // app._route = route  _route setter\n}\n\n// 关于history.cb\n// class history\nlisten(cb) {\n    this.cb = cb;\n}\n\n// class Router\ninit(app) {\n    history.listen(route => {\n        this.apps.forEach(app => {\n            app._route = route;\n        })\n    })\n}\n\nrouter.history.cb = route => {\n    router.apps.forEach(app => {\n        app._route = route;\n    })\n}\n```\n\n### three class\n\n- router\n- history\n- matcher\n\n#### class Router\n\n```javascript\nclass Router {\n    constructor(options) {\n        this.app = null;\n        this.apps = [];\n        this.beforeHooks = [];\n        this.afterHooks = [];\n        this.resolveHooks = [];\n\n        // this.matcher = { match: fn, addRoutes: fn}\n        this.matcher = createMatcher(options.routes || [], this);\n\n        // 根据options.mode 创建不同的history instance\n        switch(mode) {\n            case 'history':\n                this.history = new HTML5History(this, options.base);\n            case 'hash':\n                this.history = new HashHistory(this, options.base, this.fallback);\n            case 'abstract':\n                this.history = new AbstractHistory(this, options.base);\n        }\n    }\n\n    // VueRouter.install时，在Vue的每一个组件中都混入了beforeCreate钩子函数，当vm为根组件实例时，会调用this._router.app(this);\n    init(app) {\n        this.apps.push(app);\n        this.app = app;\n\n        // 首次route匹配、跳转\n        // setupListeners = () => { this.history.setupListeners(); // ...} 添加事件监听 popstate or hashchange\n        this.history.transitionTo(\n            history.getCurrentLocation,\n            setupListeners, // onComplete\n            setupListeners // onAbort\n        );\n\n        // this.history.cb = cb 会在transitionTo -> confirmTransition -> 之后调用\n        this.history.listen(route => {\n            this.apps.forEach(app => {\n                app_route = route; // setter 派发更新\n            })\n        })\n\n    }\n}\n```\n\n#### class History\n\n\n\n```javascript\nclass History {\n    constructor() {}\n\n    transitionTo(location, onComplete, onAbort) {\n        const route = this.router.match(location, this.current); // 匹配要跳转的路由\n        this.confirmTransition(\n            route,\n            // success cb\n            () => {\n                // ...\n            },\n            // fail cb\n            () => {\n                // ...\n            }\n        )\n    }\n\n    // 确认切换\n    confirmTransition(route, onComplete, onAbort) {\n        isSameRoute(route, current) && return;\n\n        const { updated, deactivated, activated } = resolveQueue(this.current.matched, route.matched);\n    }\n}\n```\n==matched 是按照组件顺序排列的嘛? ==\n\n\n#### class Matcher\n\n\n\n\n\n\n","tags":[],"folderPathname":"/router","data":{},"createdAt":"2020-12-30T12:16:13.715Z","updatedAt":"2020-12-30T12:22:54.310Z","trashed":true,"_rev":"sih4ah1gc"}